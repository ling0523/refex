<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Refex数据响应式框架测试</title>
		<style type="text/css">
			[refex-cloak] {
				display: none;
			}
			fieldset{
				margin-bottom: 40px;
			}
		</style>
	</head>
	<body>
		<div id="app" refex-cloak>
			<fieldset>
				<legend>双括号渲染数据（在文本和属性上使用）</legend>
				<p class="{{cls}}" data-msg="{{msg}}">{{msg}}</p>
				<div>
					<!-- 属性值为true时，直接设置属性，不会赋值，属性值为false会移除属性 -->
					<button type="button" disabled="{{disabled}}">动态属性值的Button</button>
					<button {{btnattr}}="button">动态属性的Button</button>
				</div>
			</fieldset>
			<fieldset>
				<legend>#事件绑定（在元素上使用#开头的修饰符）</legend>
				<div>
					<button type="button" #click="change">点我试试</button>
					<button type="button" #click="change2('hello')">带参数的点击</button>
					<input type="text" #blur="inputblur" />
				</div>
			</fieldset>
			<fieldset>
				<legend>@for循环</legend>
				<ul>
					<li @for="(item,index) in list" data-index="{{index}}">{{item}}</li>
				</ul>
			</fieldset>
			<fieldset>
				<legend>@if条件渲染</legend>
				<div>
					<button #click="change3" type="button">点击{{show?'隐藏':'显示'}}下方的DIV</button>
				</div>
				<div @if="show" style="padding: 20px 0;margin-bottom: 20px;">这是一个加了@if指令控制的DIV</div>
			</fieldset>
			<fieldset>
				<legend>@if与@for结合</legend>
				<div>
					<button #click="change4">{{min==0?'只显示>30的数据':'显示全部'}}</button>
				</div>
				<ul>
					<li @for="item in list2" @if="item>min">{{item}}</li>
				</ul>
			</fieldset>
			<fieldset>
				<legend>自定义指令实现（这里实现的是输入框获取焦点）</legend>
				<div>
					<input id="el" type="text" @focus>
				</div>
			</fieldset>
			<fieldset>
				<legend>双向绑定实现(需要自己封装指令)</legend>
				<div>
					<div #click="change">{{value}}</div>
					<div><input @model  value="{{value}}" placeholder="请输入内容" /></div>
				</div>
			</fieldset>
			<fieldset>
				<legend>自定义组件</legend>
				<div>
					<el-input @model class="{{list}}" value="{{value}}"></el-input>
				</div>
			</fieldset>
		</div>
	</body>
	<script src="../dist/refex.js" type="text/javascript" charset="utf-8"></script>
	<script>
		//引入必要的方法
		const { proxy, useProxy, h } = Refex
		//构建响应式数据
		const state = proxy({
			msg:"欢迎使用refex",
			disabled:true,
			btnattr:'class',
			change:function(e){
				//alert('hello world')
				this.list = []
			},
			change2:function(e,data){
				alert('带的参数是：'+data)
			},
			inputblur:function(e){
				alert('输入框失去焦点触发')
			},
			list:['vue','react','angluar','refex'],
			list2:[10,9,7,92,4,20,32,44,52],
			show:false,
			min:0,
			value:'22',
			change3:function(){
				this.show=!this.show
			},
			change4:function(){
				this.min = this.min?0:30
			},
			cls:{
				'input':true,
				'css':false
			}
		})
		//生命周期函数
		state.onBeforeMount = function(){
			console.log('渲染之前', this)
		}
		state.onMounted = function() {
			console.log('渲染完毕', this)
		}
		state.onBeforeUpdate = function(property, value, oldValue, target) {
			console.log('state更新之前', property, value, oldValue, target)
		}
		state.onUpdated = function(property, value, oldValue, target) {
			console.log('state更新之后', property, value, oldValue, target)
		}
		
		//实现一个输入框自动获取焦点的指令
		state.directive('focus',{
			mounted:function(el,data,modifier,vnode){
				el.focus()
			}
		})
		
		//实现一个双向绑定的指令
		state.directive('model',{
			mounted:function(el,value,modifier,exp,vnode){
				el.addEventListener('input',e=>{
					this.value = el.value
				})
			},
			updated:function(el,value,modifier,exp){
				el.value = this.value
			}
		})
		
		//实现一个自定义组件
		state.component('el-input',function(props){
			return h('input')
		})
		
		//挂载到指定元素
		state.mount('#app')

		//拿到可直接操作的响应式对象
		const snap = useProxy(state)
		
		//数据监听
		state.watch('count', function(newValue, oldValue) {
			console.log(newValue, oldValue)
		})
	</script>
</html>
